<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="config-editor.css" />
    <title>Sneeder Quest Config Editor</title>
  </head>
  <body>
    <div class="header">
      <div
        style="
          display: flex;
          justify-content: space-between;
          align-items: center;
        "
      >
        <div>
          <h1>Sneeder Quest Configuration Editor</h1>
          <p>Analyze and edit game configuration data</p>
        </div>
      </div>
    </div>

    <div class="stats-grid" id="statsGrid" style="display: none">
      <!-- Statistics will be populated here when needed -->
    </div>

    <div class="editor-section">
      <h2>Configuration Editor</h2>

      <div class="section-tabs" id="sectionTabs">
        <!-- Tabs will be populated here -->
      </div>

      <div class="editor-container">
        <div class="left-panel">
          <div class="current-stats" id="currentStats">
            <!-- Current section stats will show here -->
          </div>

          <div class="action-buttons">
            <button class="action-btn save-btn" onclick="saveConfig()">
              üíæ Save Changes
            </button>
            <button class="action-btn export-btn" onclick="exportJSON()">
              üìÑ Export JSON
            </button>
          </div>
        </div>

        <div class="editor-content" id="tabContents">
          <!-- Tab contents will be populated here -->
        </div>
      </div>
    </div>

    <script>
      // Configuration data - will be loaded from config.js
      let K = {};
      let originalConfigText = ""; // Store the original file content

      // Organized sections into categories
      const sectionCategories = {
        Character: ["Races", "Klasses", "Titles", "ImpressiveTitles", "Spells"],
        Equipment: [
          "Weapons",
          "Accessories",
          "Headwear",
          "Eyewear",
          "BodyArmor",
          "Jackets",
          "Gloves",
          "Wristwear",
          "Belts",
          "Legwear",
          "Footwear",
          "Armors",
        ],
        Attributes: [
          "OffenseAttrib",
          "DefenseAttrib",
          "OffenseBad",
          "DefenseBad",
        ],
        "Items & Loot": ["Specials", "ItemAttrib", "ItemOfs", "BoringItems"],
        "Combat & Enemies": ["Monsters", "MonMods"],
      };

      // Flattened list for compatibility
      const wantedSections = Object.values(sectionCategories).flat();

      let currentCategory = "Character";
      let currentSection = "Races";

      function analyzeConfig() {
        const stats = {};

        for (const [key, value] of Object.entries(K)) {
          const analysis = {
            total: value.length,
            type: "simple",
          };

          // Detect if items have level/stat information
          if (value.length > 0 && typeof value[0] === "string") {
            if (value[0].includes("|")) {
              const parts = value[0].split("|");
              if (parts.length === 2 && !isNaN(parseInt(parts[1]))) {
                analysis.type = "leveled";
                analysis.levels = analyzeLevels(value);
              } else if (parts.length === 3) {
                analysis.type = "complex";
                analysis.levels = analyzeLevels(value);
              } else if (parts.length === 2) {
                analysis.type = "attributed";
              }
            }
          }

          stats[key] = analysis;
        }

        return stats;
      }

      function analyzeLevels(items) {
        const levelCounts = {};
        let minLevel = Infinity;
        let maxLevel = -Infinity;

        items.forEach((item) => {
          const parts = item.split("|");
          if (parts.length >= 2) {
            const level = parseInt(parts[1]);
            if (!isNaN(level)) {
              levelCounts[level] = (levelCounts[level] || 0) + 1;
              minLevel = Math.min(minLevel, level);
              maxLevel = Math.max(maxLevel, level);
            }
          }
        });

        return {
          counts: levelCounts,
          min: minLevel === Infinity ? 0 : minLevel,
          max: maxLevel === -Infinity ? 0 : maxLevel,
          unique: Object.keys(levelCounts).length,
        };
      }

      function renderCurrentStats(section) {
        const stats = analyzeConfig();
        const data = stats[section];
        const container = document.getElementById("currentStats");

        if (!data) {
          container.innerHTML = "";
          return;
        }

        let content = `
                <div class="current-stat-card">
                    <h3>${section} Statistics</h3>
                    <div class="stat-item">
                        <span>Total Items:</span>
                        <strong>${data.total}</strong>
                    </div>
                    <div class="stat-item">
                        <span>Type:</span>
                        <strong>${data.type}</strong>
                    </div>
            `;

        if (data.levels) {
          content += `
                    <div class="stat-item">
                        <span>Level Range:</span>
                        <strong>${data.levels.min} - ${data.levels.max}</strong>
                    </div>
                    <div class="stat-item">
                        <span>Unique Levels:</span>
                        <strong>${data.levels.unique}</strong>
                    </div>
                `;

          // Add level breakdown visualization
          content +=
            '<div style="margin-top: 10px;"><strong>Level Distribution:</strong></div>';
          content += '<div class="level-breakdown">';
          for (let i = data.levels.min; i <= data.levels.max; i++) {
            const count = data.levels.counts[i] || 0;
            const cellClass = count > 0 ? "level-has-items" : "level-empty";
            content += `<div class="level-cell ${cellClass}" title="Level ${i}: ${count} items">${i}<br><small>${count}</small></div>`;
          }
          content += "</div>";
        }

        content += "</div>";
        container.innerHTML = content;
      }

      function renderTabs() {
        const tabsContainer = document.getElementById("sectionTabs");
        const contentsContainer = document.getElementById("tabContents");

        tabsContainer.innerHTML = "";
        contentsContainer.innerHTML = "";

        // Create category headers and tabs
        for (const [categoryName, sections] of Object.entries(
          sectionCategories
        )) {
          // Create category header
          const categoryHeader = document.createElement("div");
          categoryHeader.className = `category-header ${
            categoryName === currentCategory ? "active" : ""
          }`;
          categoryHeader.textContent = categoryName;
          categoryHeader.onclick = () => switchCategory(categoryName);
          tabsContainer.appendChild(categoryHeader);

          // Create section tabs for this category
          const categoryTabs = document.createElement("div");
          categoryTabs.className = `category-tabs ${
            categoryName === currentCategory ? "active" : ""
          }`;
          categoryTabs.id = `category-${categoryName}`;

          sections.forEach((section) => {
            if (K[section]) {
              const tab = document.createElement("button");
              tab.className = `tab ${
                section === currentSection ? "active" : ""
              }`;
              tab.textContent = section;
              tab.onclick = () => switchTab(section);
              categoryTabs.appendChild(tab);

              // Create content
              const content = document.createElement("div");
              content.className = `tab-content ${
                section === currentSection ? "active" : ""
              }`;
              content.id = `tab-${section}`;
              content.innerHTML = renderSectionContent(section);
              contentsContainer.appendChild(content);
            }
          });

          tabsContainer.appendChild(categoryTabs);
        }
      }

      function renderSectionContent(section) {
        const items = K[section];

        // Debug info
        console.log(`Rendering ${section}: ${items.length} items`, items);

        return `
                <div style="margin-bottom: 10px; color: #666; font-size: 12px;">
                    <strong>${items.length} items total</strong>
                </div>
                
                <button class="btn btn-add" onclick="showAddForm('${section}')">Add New Item</button>
                
                <div class="add-form" id="addForm-${section}">
                    <input type="text" id="newItem-${section}" placeholder="Enter new item (use | for separators)">
                    <button class="btn btn-add" onclick="addItem('${section}')">Add</button>
                    <button class="btn" onclick="hideAddForm('${section}')">Cancel</button>
                </div>
                
                <div class="item-list">
                    ${items
                      .map(
                        (item, index) => `
                        <div class="item">
                            <span class="item-text">${item}</span>
                            <div class="item-actions">
                                <button class="btn btn-edit" onclick="editItem('${section}', ${index})">Edit</button>
                                <button class="btn btn-delete" onclick="deleteItem('${section}', ${index})">Delete</button>
                            </div>
                        </div>
                    `
                      )
                      .join("")}
                </div>
            `;
      }

      function switchCategory(categoryName) {
        currentCategory = categoryName;

        // Update category header appearance
        document.querySelectorAll(".category-header").forEach((header) => {
          header.classList.remove("active");
        });
        document
          .querySelector(
            `.category-header:nth-child(${
              Object.keys(sectionCategories).indexOf(categoryName) * 2 + 1
            })`
          )
          .classList.add("active");

        // Show/hide category tabs
        document.querySelectorAll(".category-tabs").forEach((tabs) => {
          tabs.classList.remove("active");
        });
        document
          .getElementById(`category-${categoryName}`)
          .classList.add("active");

        // Switch to first section in category
        const firstSection = sectionCategories[categoryName][0];
        if (K[firstSection]) {
          switchTab(firstSection);
        }
      }

      function switchTab(section) {
        currentSection = section;

        // Update tab appearance within current category
        document.querySelectorAll(".tab").forEach((tab) => {
          tab.classList.remove("active");
        });

        // Find and highlight the correct tab
        const categoryTabs = document.getElementById(
          `category-${currentCategory}`
        );
        if (categoryTabs) {
          const tabs = categoryTabs.querySelectorAll(".tab");
          const sectionIndex =
            sectionCategories[currentCategory].indexOf(section);
          if (sectionIndex >= 0 && tabs[sectionIndex]) {
            tabs[sectionIndex].classList.add("active");
          }
        }

        // Update content
        document.querySelectorAll(".tab-content").forEach((content) => {
          content.classList.remove("active");
        });
        const targetContent = document.getElementById(`tab-${section}`);
        if (targetContent) {
          targetContent.classList.add("active");
        }

        // Update stats for current section
        renderCurrentStats(section);
      }

      function showAddForm(section) {
        document.getElementById(`addForm-${section}`).style.display = "block";
        document.getElementById(`newItem-${section}`).focus();
      }

      function hideAddForm(section) {
        document.getElementById(`addForm-${section}`).style.display = "none";
        document.getElementById(`newItem-${section}`).value = "";
      }

      function addItem(section) {
        const input = document.getElementById(`newItem-${section}`);
        const newItem = input.value.trim();

        if (newItem) {
          K[section].push(newItem);
          input.value = "";
          hideAddForm(section);
          renderTabs();
          renderCurrentStats(section); // Update current stats
        }
      }

      function editItem(section, index) {
        const currentValue = K[section][index];
        const newValue = prompt("Edit item:", currentValue);

        if (newValue !== null && newValue.trim() !== "") {
          K[section][index] = newValue.trim();
          renderTabs();
          renderCurrentStats(section); // Update current stats
        }
      }

      function deleteItem(section, index) {
        if (confirm("Are you sure you want to delete this item?")) {
          K[section].splice(index, 1);
          renderTabs();
          renderCurrentStats(section); // Update current stats
        }
      }

      function saveConfig() {
        if (!originalConfigText) {
          alert(
            "Cannot save: No original config.js was loaded. Use Export instead."
          );
          return;
        }

        try {
          const updatedConfig = generateConfigJS();

          // Create a download link for the updated config
          const blob = new Blob([updatedConfig], { type: "text/javascript" });
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "config.js";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        } catch (error) {
          alert("Error saving config: " + error.message);
          console.error("Save error:", error);
        }
      }

      function exportJSON() {
        const jsonText = JSON.stringify(K, null, 2);
        downloadFile("config.json", jsonText);
      }

      function generateConfigJS() {
        if (originalConfigText) {
          // Replace only the sections we've been editing in the original file
          let updatedConfig = originalConfigText;

          wantedSections.forEach((section) => {
            if (K[section]) {
              // Find the existing section in the original text
              const regex = new RegExp(
                `(K\\.${section}\\s*=\\s*\\[)[\\s\\S]*?(\\];)`,
                "i"
              );

              // Generate the new array content
              const newArrayContent = K[section]
                .map((item) => `  "${item}"`)
                .join(",\n");
              const replacement = `$1\n${newArrayContent}\n$2`;

              updatedConfig = updatedConfig.replace(regex, replacement);
            }
          });

          return updatedConfig;
        } else {
          // Fallback: generate a new config file (this will lose other sections)
          let output = "// Configuration and constants for Sneeder Quest\n\n";
          output += "let RevString = '&rev=6';\n\n";
          output += "var K = {};\n\n";

          // Group output by categories for better organization
          for (const [categoryName, sections] of Object.entries(
            sectionCategories
          )) {
            output += `// ${categoryName}\n`;
            sections.forEach((section) => {
              if (K[section]) {
                output += `K.${section} = [\n`;
                K[section].forEach((item) => {
                  output += `  "${item}",\n`;
                });
                output += "];\n\n";
              }
            });
            output += "\n";
          }

          return output;
        }
      }

      function downloadFile(filename, content) {
        const blob = new Blob([content], { type: "text/plain" });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      }

      function loadConfigFromFile() {
        fetch("config.js")
          .then((response) => {
            if (!response.ok) {
              throw new Error("Could not find config.js in the same directory");
            }
            return response.text();
          })
          .then((configText) => {
            parseConfigFile(configText);
          })
          .catch((error) => {
            console.error("Error loading config.js:", error);
            document.getElementById("statsGrid").innerHTML = `
                        <div class="stat-card" style="grid-column: 1 / -1; text-align: center; color: #e74c3c;">
                            <h3>‚ö†Ô∏è Could not load config.js</h3>
                            <p>Make sure config.js is in the same directory as this HTML file.</p>
                            <p>You can also use the "Import Config File" button to manually select your config.js file.</p>
                        </div>
                    `;
          });
      }

      function parseConfigFile(configText) {
        try {
          // Store the original config text for export
          originalConfigText = configText;

          // Extract each K.section array from the config file
          K = {};

          wantedSections.forEach((section) => {
            // Look for K.SectionName = [
            const regex = new RegExp(
              `K\\.${section}\\s*=\\s*\\[([\\s\\S]*?)\\];`,
              "i"
            );
            const match = configText.match(regex);

            if (match) {
              try {
                // Parse the array content
                const arrayContent = "[" + match[1] + "]";
                K[section] = eval(arrayContent);
                console.log(`Loaded ${section}: ${K[section].length} items`);
              } catch (parseError) {
                console.warn(`Could not parse ${section}:`, parseError);
                K[section] = [];
              }
            } else {
              console.warn(`Section ${section} not found in config.js`);
              K[section] = [];
            }
          });

          // Update the interface
          renderTabs();
          renderCurrentStats(currentSection);

          const totalItems = Object.values(K).reduce(
            (sum, arr) => sum + arr.length,
            0
          );
          console.log(
            `Successfully loaded ${
              Object.keys(K).length
            } sections with ${totalItems} total items`
          );
        } catch (error) {
          console.error("Error parsing config file:", error);
          alert("Error parsing config.js: " + error.message);
        }
      }

      function toggleDarkMode() {
        // Removed - always dark mode now
      }

      // Initialize the editor
      function initializeEditor() {
        // Always use dark mode now

        // Try to automatically load config.js from the same directory
        loadConfigFromFile();
      }

      // Initialize the editor
      document.addEventListener("DOMContentLoaded", function () {
        initializeEditor();
      });
    </script>
  </body>
</html>
